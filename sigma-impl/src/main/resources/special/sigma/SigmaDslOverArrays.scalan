package special.sigma {
  import scalan._

  trait SigmaDslOverArrays extends Base { self: SigmaDslOverArraysModule =>
    import TestSigmaDslBuilder._;
    import TrivialSigma._;
    import Sigma._;
    import SigmaContract._;
    import Col._;
    import WOption._;
    import MonoidBuilderInst._;
    import Box._;
    import AnyValue._;
    import Context._;
    import ColOverArrayBuilder._;
    import SigmaDslBuilder._;
    import DefaultSigma._;
    import ColOverArray._;
    import ProveDlog._;
    trait DefaultSigma extends Sigma {
      def builder: Rep[TestSigmaDslBuilder] = RTestSigmaDslBuilder();
      @OverloadId(value = "and_sigma") def &&(other: Rep[Sigma]): Rep[TrivialSigma] = RTrivialSigma(DefaultSigma.this.isValid.&&(other.isValid));
      @OverloadId(value = "and_bool") def &&(other: Rep[Boolean]): Rep[TrivialSigma] = RTrivialSigma(DefaultSigma.this.isValid.&&(other));
      @OverloadId(value = "or_sigma") def ||(other: Rep[Sigma]): Rep[TrivialSigma] = RTrivialSigma(DefaultSigma.this.isValid.||(other.isValid));
      @OverloadId(value = "or_bool") def ||(other: Rep[Boolean]): Rep[TrivialSigma] = RTrivialSigma(DefaultSigma.this.isValid.||(other));
      def lazyAnd(other: Rep[Thunk[Sigma]]): Rep[TrivialSigma] = RTrivialSigma(DefaultSigma.this.isValid.&&(other.isValid));
      def lazyOr(other: Rep[Thunk[Sigma]]): Rep[TrivialSigma] = RTrivialSigma(DefaultSigma.this.isValid.||(other.isValid))
    };
    trait DefaultContract extends SigmaContract {
      def builder: Rep[TestSigmaDslBuilder] = RTestSigmaDslBuilder()
    };
    abstract class TestBox(val idBytes: Rep[WArray[Byte]], val value: Rep[Long], val propositionBytes: Rep[Col[Byte]], val registers: Rep[Col[AnyValue]]) extends Box {
      def builder: Rep[TestSigmaDslBuilder] = RTestSigmaDslBuilder();
      def id: Rep[Col[Byte]] = TestBox.this.builder.Cols.fromArray[Byte](TestBox.this.idBytes);
      def getReg[T](i: Rep[Int]): Rep[WOption[T]] = RWSpecialPredef.cast[TestValue[T]](TestBox.this.registers.apply(i))(((ClassTag.apply[TestValue[T]](toRep(classOf[special.sigma.TestValue].asInstanceOf[Class[TestValue[T]]]))): ClassTag[TestValue[T]])).map[T](fun(((x: Rep[TestValue[T]]) => x.value)).asRep[scala.Function1[TestValue[T], B]]);
      def cost: Rep[Int] = TestBox.this.idBytes.length.+(TestBox.this.propositionBytes.length).+(TestBox.this.registers.map[Int](fun(((x$1: Rep[AnyValue]) => x$1.cost)))(((ClassTag.Int): ClassTag[Int])).sum(RMonoidBuilderInst().intPlusMonoid))
    };
    abstract class TestValue[T](val value: Rep[T]) extends AnyValue {
      def cost: Rep[Int] = SigmaPredef.cost(TestValue.this.value)
    };
    abstract class TestContext(val inputs: Rep[WArray[Box]], val outputs: Rep[WArray[Box]], val height: Rep[Long], val selfBox: Rep[Box], val vars: Rep[WArray[AnyValue]]) extends Context {
      def builder: Rep[TestSigmaDslBuilder] = RTestSigmaDslBuilder();
      def HEIGHT: Rep[Long] = TestContext.this.height;
      def SELF: Rep[Box] = TestContext.this.selfBox;
      def INPUTS: Rep[Col[Box]] = TestContext.this.builder.Cols.fromArray[Box](TestContext.this.outputs);
      def OUTPUTS: Rep[Col[Box]] = TestContext.this.builder.Cols.fromArray[Box](TestContext.this.outputs);
      def getVar[T](id: Rep[Byte]): Rep[T] = RWSpecialPredef.cast[TestValue[T]](TestContext.this.vars.apply(id.-(toRep(1.asInstanceOf[Int]))))(((ClassTag.apply[TestValue[T]](toRep(classOf[special.sigma.TestValue].asInstanceOf[Class[TestValue[T]]]))): ClassTag[TestValue[T]])).map[T](fun(((x$2: Rep[TestValue[T]]) => x$2.value))).get
    };
    abstract class TestSigmaDslBuilder extends SigmaDslBuilder {
      def Cols: Rep[ColOverArrayBuilder] = RColOverArrayBuilder();
      def verify(cond: Rep[Boolean]): Rep[Boolean] = cond;
      def verifyZK(proof: Rep[Sigma]): Rep[Boolean] = proof.isValid;
      def allOf(conditions: Rep[Col[Boolean]]): Rep[Boolean] = conditions.forall(fun(((c: Rep[Boolean]) => c)));
      def anyOf(conditions: Rep[Col[Boolean]]): Rep[Boolean] = conditions.exists(fun(((c: Rep[Boolean]) => c)));
      def allZK(proofs: Rep[Col[Sigma]]): Rep[TrivialSigma] = RTrivialSigma(proofs.forall(fun(((p: Rep[Sigma]) => p.isValid))));
      def anyZK(proofs: Rep[Col[Sigma]]): Rep[TrivialSigma] = RTrivialSigma(proofs.forall(fun(((p: Rep[Sigma]) => p.isValid))))
    };
    abstract class TrivialSigma(val isValid: Rep[Boolean]) extends Sigma with DefaultSigma {
      def propBytes: Rep[Col[Byte]] = TrivialSigma.this.builder.Cols.apply[Byte](IF(TrivialSigma.this.isValid).THEN(toRep(1.asInstanceOf[Byte])).ELSE(toRep(0.asInstanceOf[Byte])))
    };
    abstract class ProveDlogEvidence(val value: Rep[WECPoint]) extends ProveDlog with DefaultSigma {
      def propBytes: Rep[Col[Byte]] = RColOverArray(ProveDlogEvidence.this.value.getEncoded(toRep(true.asInstanceOf[Boolean])));
      def isValid: Rep[Boolean] = toRep(true.asInstanceOf[Boolean])
    };
    trait DefaultSigmaCompanion;
    trait DefaultContractCompanion;
    trait TestBoxCompanion;
    trait TestValueCompanion;
    trait TestContextCompanion;
    trait TestSigmaDslBuilderCompanion;
    trait TrivialSigmaCompanion;
    trait ProveDlogEvidenceCompanion
  }
}