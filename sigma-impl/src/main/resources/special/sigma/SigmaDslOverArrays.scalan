package special.sigma {
  import scalan._

  trait SigmaDslOverArrays extends Base { self: SigmaDslOverArraysModule =>
    trait DefaultSigma extends Sigma {
      def builder: Rep[SigmaDslBuilderOverArray] = SigmaDslBuilderOverArray();
      @OverloadId(value = "and_sigma") def &&(other: Rep[Sigma]): Rep[TrivialSigma] = TrivialSigma(DefaultSigma.this.isValid.&&(other.isValid));
      @OverloadId(value = "and_bool") def &&(other: Rep[Boolean]): Rep[TrivialSigma] = TrivialSigma(DefaultSigma.this.isValid.&&(other));
      @OverloadId(value = "or_sigma") def ||(other: Rep[Sigma]): Rep[TrivialSigma] = TrivialSigma(DefaultSigma.this.isValid.||(other.isValid));
      @OverloadId(value = "or_bool") def ||(other: Rep[Boolean]): Rep[TrivialSigma] = TrivialSigma(DefaultSigma.this.isValid.||(other))
    };
    trait DefaultContract extends SigmaContract {
      def builder: Rep[SigmaDslBuilderOverArray] = SigmaDslBuilderOverArray();
      def verify(cond: Rep[Boolean]): Rep[Boolean] = cond;
      def verifyZK(proof: Rep[Sigma]): Rep[Boolean] = proof.isValid;
      def allOf(conditions: Rep[Col[Boolean]]): Rep[Boolean] = conditions.forall(fun(((c: Rep[Boolean]) => c)));
      def anyOf(conditions: Rep[Col[Boolean]]): Rep[Boolean] = conditions.exists(fun(((c: Rep[Boolean]) => c)));
      def allZK(proofs: Rep[Col[Sigma]]): Rep[TrivialSigma] = TrivialSigma(proofs.forall(fun(((p: Rep[Sigma]) => p.isValid))));
      def anyZK(proofs: Rep[Col[Sigma]]): Rep[TrivialSigma] = TrivialSigma(proofs.forall(fun(((p: Rep[Sigma]) => p.isValid))))
    };
    abstract class TestBox(val idBytes: Rep[WArray[Byte]], val value: Rep[Long], val propositionBytes: Rep[Col[Byte]], val registers: Rep[Col[Any]]) extends Box {
      def builder: Rep[SigmaDslBuilderOverArray] = SigmaDslBuilderOverArray();
      def id: Rep[Col[Byte]] = TestBox.this.builder.Collections.fromArray[Byte](TestBox.this.idBytes);
      def cost: Rep[Nothing] = scala.Predef.???
    };
    abstract class ContextOverArrays(val inputs: Rep[WArray[Box]], val outputs: Rep[WArray[Box]], val HEIGHT: Rep[Long], val SELF: Rep[Box], val vars: Rep[WArray[Any]]) extends Context {
      def builder: Rep[SigmaDslBuilderOverArray] = SigmaDslBuilderOverArray();
      def INPUTS: Rep[Col[Box]] = ContextOverArrays.this.builder.Collections.fromArray[Box](ContextOverArrays.this.outputs);
      def OUTPUTS: Rep[Col[Box]] = ContextOverArrays.this.builder.Collections.fromArray[Box](ContextOverArrays.this.outputs);
      def getVar[T](id: Rep[Byte]): Rep[T] = WSpecialPredef.cast[T](ContextOverArrays.this.vars.apply(id.toInt)).get
    };
    abstract class SigmaDslBuilderOverArray extends SigmaDslBuilder {
      def Collections: Rep[ColOverArrayBuilder] = ColOverArrayBuilder()
    };
    abstract class TrivialSigma(val isValid: Rep[Boolean]) extends Sigma with DefaultSigma {
      def propBytes: Rep[Col[Byte]] = TrivialSigma.this.builder.Collections.apply[Byte](IF(TrivialSigma.this.isValid).THEN(toRep(1.asInstanceOf[Byte])).ELSE(toRep(0.asInstanceOf[Byte])))
    };
    abstract class ProveDlogEvidence(val value: Rep[WECPoint]) extends ProveDlog with DefaultSigma {
      def propBytes: Rep[Col[Byte]] = ColOverArray(ProveDlogEvidence.this.value.getEncoded(toRep(true.asInstanceOf[Boolean])));
      def isValid: Rep[Boolean] = toRep(true.asInstanceOf[Boolean])
    };
    trait DefaultSigmaCompanion;
    trait DefaultContractCompanion;
    trait TestBoxCompanion;
    trait ContextOverArraysCompanion;
    trait SigmaDslBuilderOverArrayCompanion;
    trait TrivialSigmaCompanion;
    trait ProveDlogEvidenceCompanion
  }
}