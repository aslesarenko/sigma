package special.smart {
  import scalan._

  trait Examples extends Base { self: ExamplesModule =>
    abstract class LockWithPublicKey(val publicKey: Rep[PublicKey], val value: Rep[Value]) extends Def[LockWithPublicKey] with Contract {
      @clause def spend(sig: Rep[Signature]): Rep[Unit] = {
        LockWithPublicKey.this.verify(LockWithPublicKey.this.checkSig(LockWithPublicKey.this.publicKey, sig));
        LockWithPublicKey.this.unlock(LockWithPublicKey.this.value)
      }
    };
    abstract class LockWithMultisig(val pubKey1: Rep[PublicKey], val pubKey2: Rep[PublicKey], val pubKey3: Rep[PublicKey], val value: Rep[Value]) extends Def[LockWithMultisig] with Contract {
      @clause def spend(sig1: Rep[Signature], sig2: Rep[Signature]): Rep[Unit] = {
        LockWithMultisig.this.verify(LockWithMultisig.this.checkMultiSig(WArray.apply[PublicKey](LockWithMultisig.this.pubKey1, LockWithMultisig.this.pubKey2, LockWithMultisig.this.pubKey3)(((ClassTag.apply[PublicKey](toRep(classOf[special.smart.PublicKey].asInstanceOf[Class[PublicKey]]))): ClassTag[PublicKey])), WArray.apply[Signature](sig1, sig2)(((ClassTag.apply[Signature](toRep(classOf[special.smart.Signature].asInstanceOf[Class[Signature]]))): ClassTag[Signature]))));
        LockWithMultisig.this.unlock(LockWithMultisig.this.value)
      }
    };
    abstract class LockWithPublicKeyHash(val pubKeyHash: Rep[Sha256[PublicKey]], val value: Rep[Value]) extends Def[LockWithPublicKeyHash] with Contract {
      @clause def spend(pubKey: Rep[PublicKey], sig: Rep[Signature]): Rep[Unit] = {
        LockWithPublicKeyHash.this.verify(LockWithPublicKeyHash.this.sha256[PublicKey](pubKey).==(LockWithPublicKeyHash.this.pubKeyHash));
        LockWithPublicKeyHash.this.verify(LockWithPublicKeyHash.this.checkSig(pubKey, sig));
        LockWithPublicKeyHash.this.unlock(LockWithPublicKeyHash.this.value)
      }
    };
    abstract class RevealPreimage(val hash: Rep[Sha256[Bytes]], val value: Rep[Value]) extends Def[RevealPreimage] with Contract {
      @clause def reveal(string: Rep[Bytes]): Rep[Unit] = {
        RevealPreimage.this.verify(RevealPreimage.this.sha256[Bytes](string).==(RevealPreimage.this.hash));
        RevealPreimage.this.unlock(RevealPreimage.this.value)
      }
    };
    abstract class RevealCollision(val value: Rep[Value]) extends Def[RevealCollision] with Contract {
      @clause def reveal(string1: Rep[Bytes], string2: Rep[Bytes]): Rep[Unit] = {
        RevealCollision.this.verify(string1.!=(string2));
        RevealCollision.this.verify(RevealCollision.this.sha1[Bytes](string1).==(RevealCollision.this.sha1[Bytes](string2)));
        RevealCollision.this.unlock(RevealCollision.this.value)
      }
    };
    abstract class RevealFixedPoint(val value: Rep[Value]) extends Def[RevealFixedPoint] with Contract {
      @clause def reveal(hash: Rep[Bytes]): Rep[Unit] = {
        RevealFixedPoint.this.verify(RevealFixedPoint.this.bytes[Sha256[Bytes]](RevealFixedPoint.this.sha256[Bytes](hash)).==(hash));
        RevealFixedPoint.this.unlock(RevealFixedPoint.this.value)
      }
    };
    abstract class LockUntil(val publicKey: Rep[PublicKey], val time: Rep[Time], val value: Rep[Value]) extends Def[LockUntil] with Contract {
      @clause def spend(sig: Rep[Signature]): Rep[Unit] = {
        LockUntil.this.verify(LockUntil.this.checkSig(LockUntil.this.publicKey, sig));
        LockUntil.this.verify(LockUntil.this.after(LockUntil.this.time));
        LockUntil.this.unlock(LockUntil.this.value)
      }
    };
    abstract class LockDelay(val publicKey: Rep[PublicKey], val delay: Rep[Duration], val value: Rep[Value]) extends Def[LockDelay] with Contract {
      @clause def spend(sig: Rep[Signature]): Rep[Unit] = {
        LockDelay.this.verify(LockDelay.this.checkSig(LockDelay.this.publicKey, sig));
        LockDelay.this.verify(LockDelay.this.older(LockDelay.this.delay));
        LockDelay.this.unlock(LockDelay.this.value)
      }
    };
    abstract class TransferWithTimeout(val sender: Rep[PublicKey], val recipient: Rep[PublicKey], val timeout: Rep[Time], val value: Rep[Value]) extends Def[TransferWithTimeout] with Contract {
      @clause def transfer(senderSig: Rep[Signature], recipientSig: Rep[Signature]): Rep[Unit] = {
        TransferWithTimeout.this.verify(TransferWithTimeout.this.checkSig(TransferWithTimeout.this.sender, senderSig));
        TransferWithTimeout.this.verify(TransferWithTimeout.this.checkSig(TransferWithTimeout.this.recipient, recipientSig));
        TransferWithTimeout.this.unlock(TransferWithTimeout.this.value)
      };
      @clause def timeout(senderSig: Rep[Signature]): Rep[Unit] = {
        TransferWithTimeout.this.verify(TransferWithTimeout.this.checkSig(TransferWithTimeout.this.sender, senderSig));
        TransferWithTimeout.this.verify(TransferWithTimeout.this.after(TransferWithTimeout.this.timeout));
        TransferWithTimeout.this.unlock(TransferWithTimeout.this.value)
      }
    };
    abstract class EscrowWithDelay(val sender: Rep[PublicKey], val recipient: Rep[PublicKey], val escrow: Rep[PublicKey], val delay: Rep[Duration], val value: Rep[Value]) extends Def[EscrowWithDelay] with Contract {
      @clause def transfer(sig1: Rep[Signature], sig2: Rep[Signature]): Rep[Unit] = {
        EscrowWithDelay.this.verify(EscrowWithDelay.this.checkMultiSig(WArray.apply[PublicKey](EscrowWithDelay.this.sender, EscrowWithDelay.this.recipient, EscrowWithDelay.this.escrow)(((ClassTag.apply[PublicKey](toRep(classOf[special.smart.PublicKey].asInstanceOf[Class[PublicKey]]))): ClassTag[PublicKey])), WArray.apply[Signature](sig1, sig2)(((ClassTag.apply[Signature](toRep(classOf[special.smart.Signature].asInstanceOf[Class[Signature]]))): ClassTag[Signature]))));
        EscrowWithDelay.this.unlock(EscrowWithDelay.this.value)
      };
      @clause def timeout(sig: Rep[Signature]): Rep[Unit] = {
        EscrowWithDelay.this.verify(EscrowWithDelay.this.checkSig(EscrowWithDelay.this.sender, sig));
        EscrowWithDelay.this.verify(EscrowWithDelay.this.older(EscrowWithDelay.this.delay));
        EscrowWithDelay.this.unlock(EscrowWithDelay.this.value)
      }
    };
    abstract class VaultSpend(val hotKey: Rep[PublicKey], val coldKey: Rep[PublicKey], val delay: Rep[Duration], val value: Rep[Value]) extends Def[VaultSpend] with Contract {
      @clause def cancel(sig: Rep[Signature]): Rep[Unit] = {
        VaultSpend.this.verify(VaultSpend.this.checkSig(VaultSpend.this.coldKey, sig));
        VaultSpend.this.unlock(VaultSpend.this.value)
      };
      @clause def complete(sig: Rep[Signature]): Rep[Unit] = {
        VaultSpend.this.verify(VaultSpend.this.older(VaultSpend.this.delay));
        VaultSpend.this.verify(VaultSpend.this.checkSig(VaultSpend.this.hotKey, sig));
        VaultSpend.this.unlock(VaultSpend.this.value)
      }
    };
    trait LockWithPublicKeyCompanion;
    trait LockWithMultisigCompanion;
    trait LockWithPublicKeyHashCompanion;
    trait RevealPreimageCompanion;
    trait RevealCollisionCompanion;
    trait RevealFixedPointCompanion;
    trait LockUntilCompanion;
    trait LockDelayCompanion;
    trait TransferWithTimeoutCompanion;
    trait EscrowWithDelayCompanion;
    trait VaultSpendCompanion
  }
}